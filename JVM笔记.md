# JVM笔记

# 学习目标

## 1、JVM体系结构

## 2、堆体系结构

## 3、GC算法实现

# 1、基础

## 1、双亲委派机制（双亲优先）

- 根类装载器：JAVA_HOME/jre/lib/rt.jar
- 拓展类装载器：JAVA_HOME/jre/lib/ext/*.jar
- 系统泪装载器：classpath下

- class文件永远找最顶层的双亲类加载，也就是如果有最顶层的根类装载器就用根类装载器，如果没有，就看拓展类装载器，如果没有就看系统类装载器。
- 解决问题：假如自定义的程序有个java.lang.String类，如果没有双亲委派机制，那么就会破坏程序运行。因此，有了双亲委派机制，可以保证程序的安全。

## 2、Java沙箱机制



# 2、JVM结构

## 1，本地方法栈

- Java native inferface，调用C，实现底层操作，放置其中的内存结构。

## 2、程序计数器

1. 每个线程私有的，是一个地址（指针），指向**方法区**中的方法字节码，也就是存储即将执行的命令所在的地址。
2. 有执行引擎读取下一条指令。

## 3、Java栈

1. 线程私有的，一旦结束了线程，那么内存也释放了，不存在内存问题。
2. 8种基本类型+对象引用变量+实例方法都是在栈内分配。
3. 主要存放以下：
   1. 本地变量：包括参数，方法内定义的变量，返回值。
   2. 栈操作：入栈，出栈。
   3. 栈帧数据：方法放入栈后的描述（说白了就是方法）。



## 4、方法区

（名字叫方法区，所以方法就放在这里？大错特错！）

1. 线程共享，定义了一个类所有的字段、方法、字节码、构造方法、接口定义，包括：
   - 类信息（构造方法与接口定义）。
   - 静态变量（类变量）。
   - 常量。
   - 运行时候常量池。
2. 实例变量存放在堆中，与方法区无关。

## 5、**堆（最重要的）**

### 1、新生代

相关术语：伊甸区，幸存区0，幸存区1

工作流程：

new object之后，假如伊甸区内存不够，则启动GC，存活的未回收的对象放置到幸存0区，如果幸存0区也满了，则再次启动GC，然后放置到幸存区1，假如幸存区1的也满了，则放置到年老代，假如年老代也满了，则会启动FULL GC回收，假如还是满了，则会报java.lang.OutOfMemoryError: Java heap space。注意，幸存0区，幸存1区不是固定的，是会相互交换。

### 2、年老代

### 3、永久代（jdk8之后是元空间）

存放第三方jar，不会被回收。

开发者一般称方法区为永久代，实际上有区别，永久代可以看做是方法区的具体实现。

# 3、MAT工具的使用

MAT：memory analyzer tool

## 1、功能

1. 分析dump文件，快速定位内存泄露。
2. 分析堆中对象的统计数据。
3. 获取对象相互引用的关系。
4. 采用树形展现对象相互引用关系。
5. 支持使用QQL语言查询对象的信息。

## 2、使用

# 4、GC算法

## 1、判断对象符合回收的算法

### 1、引用计数法

被引用一次+1

解决不了双向引用、双向引用的问题（类似死锁）

JVM一般不使用这样的

## 2、回收算法

### 1、复制算法

原理：

疑点：from与to是如何交换的。

年轻代使用的。伊甸区：FROM：TO=1:1:1 ，

优点：不会产生碎片。

弊端：如果存活的对象太多，处理缓慢。

### 2、标记-清除算法

原理：标记存活的对象（视频和《深入理解JVM》一书中描述有出入，书里说的标记需要回收的对象》）

- 标记：从根节点开始标记被引用的对象，也就是遍历所有的GC ROOTS，将所有的GC ROOTS可达对象标记为存活的对象。
- 清除：遍历整个堆，把未标记的对象清除。

好处：不浪费空间，不需要额外空间

弊端：

- 会暂停整个应用
- 耗时长
- 产生碎片
- 效率低，因为不要遍历整个堆。

### 3、标记-整理算法

### 4、采用分代收集算法

# 5、调优

-Xms与-Xmx相等是最好的办法，防止堆内存的浮动。m表示单位mb，默认是kb。