# JVM笔记

# 学习目标

## 1、JVM体系结构

## 2、堆体系结构

## 3、GC算法实现

# 1、基础

## 1、双亲委派机制（双亲优先）

- 根类装载器：JAVA_HOME/jre/lib/rt.jar
- 拓展类装载器：JAVA_HOME/jre/lib/ext/*.jar
- 系统泪装载器：classpath下

- class文件永远找最顶层的双亲类加载，也就是如果有最顶层的根类装载器就用根类装载器，如果没有，就看拓展类装载器，如果没有就看系统类装载器。
- 解决问题：假如自定义的程序有个java.lang.String类，如果没有双亲委派机制，那么就会破坏程序运行。因此，有了双亲委派机制，可以保证程序的安全。

## 2、Java沙箱机制



# 2、JVM结构

## 1，本地方法栈

- Java native inferface，调用C，实现底层操作，放置其中的内存结构。

## 2、程序计数器

1. 每个线程私有的，是一个地址（指针），指向**方法区**中的方法字节码，也就是存储即将执行的命令所在的地址。
2. 有执行引擎读取下一条指令。

## 3、Java栈

1. 线程私有的，一旦结束了线程，那么内存也释放了，不存在内存问题。
2. 8种基本类型+对象引用变量+实例方法都是在栈内分配。
3. 主要存放以下：
   1. 本地变量：包括参数，方法内定义的变量，返回值。
   2. 栈操作：入栈，出栈。
   3. 栈帧数据：方法放入栈后的描述（说白了就是方法）。



## 4、方法区

（名字叫方法区，所以方法就放在这里？大错特错！）

1. 线程共享，定义了一个类所有的字段、方法、字节码、构造方法、接口定义，包括：
   - 类信息（构造方法与接口定义）。
   - 静态变量（类变量）。
   - 常量。
   - 运行时候常量池。
2. 实例变量存放在堆中，与方法区无关。

## 5、**堆（最重要的）**

### 1、新生代

相关术语：伊甸区，幸存区0，幸存区1

工作流程：

new object之后，假如伊甸区内存不够，则启动GC，存活的未回收的对象放置到幸存0区，如果幸存0区也满了，则再次启动GC，然后放置到幸存区1，假如幸存区1的也满了，则放置到年老代，假如年老代也满了，则会启动FULL GC回收，假如还是满了，则会报java.lang.OutOfMemoryError: Java heap space。注意，幸存0区，幸存1区不是固定的，是会相互交换。

### 2、年老代

### 3、永久代（jdk8之后是元空间）

存放第三方jar，不会被回收。

开发者一般称方法区为永久代，实际上有区别，永久代可以看做是方法区的具体实现。

## 6、